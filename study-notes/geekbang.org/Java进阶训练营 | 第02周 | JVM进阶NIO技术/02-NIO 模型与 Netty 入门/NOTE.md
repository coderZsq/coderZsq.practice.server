# 1. Java Socket 编程

## 服务器通信原理

## Java 实现一个最简的 HTTP 服务器-01

1. 创建一个 ServerSocket
2. 绑定 8801 端口
3. 当有客户端请求时通过 accept 方法拿 到 Socket，进而可以进行处理
4. sleep 20ms，模拟业务操作(IO)
5. 模拟输出 HTTP 报文头和 hello
6. 关闭 socket
   可以浏览器访问 http://localhost:8801 思考一下有什么问题?

设置-Xmx512 然后启动
压测:
sb -u http://localhost:8801 -c 40 -N 30
wrk -c 40 -d30s http://localhost:8801

## Java 实现一个最简的 HTTP 服务器-02

改进一下，绑定 8802 端口
每个客户端请求进来时创建一个线程
有什么问题?

设置-Xmx512 然后启动
压测:
sb -u http://localhost:8802 -c 40 -N 30
wrk -c 40 -d30s http://localhost:8802

## Java 实现一个最简的 HTTP 服务器-03

再改进一下，绑定 8802 端口
创建一个固定大小的线程池来处理
why?
有什么问题?

设置-Xmx512 然后启动
压测:
sb -u http://localhost:8803 -c 40 -N 30
wrk -c 40 -d30s http://localhost:8803

## 总结一下，到目前为止，我们做了什么

单线程处理 socket
每个请求一个线程
固定大小线程池处理

# 2. 深入讨论 IO 通信

## 服务器通信过程分析

仔细分析一下，
这个过程中，存在两种类型操作:

- CPU 计算/业务处理
- IO 操作与等待/网络、磁盘、数据库

想想我们前面的例子为什么创建大量线程?

对于一个 IO 相关应用来说， 例如通过网络访问，服务器端读取本
地文件，再返回给客户端(如左图)。

这种情况下，
大部分 CPU 等资源，可能就被浪费了。

## 再深入一层的看问题

不仅面临线程 /CPU 的问题，

还要面对数据来回复制的问题。

这个一来，对每个业务处理过程，使
用一个线程以一竿子通到底的方式，
性能不是最优的，还有提升空间。

考虑一下，理想状态，是什么样的?
流水线

# 3. NIO 模型与相关概念

## 通信模型

考虑一下:

阻塞、非阻塞，
同步、异步，

有什么关系和区别?

- 同步异步 是通信模式。
- 阻塞、非阻塞 是 线程处理模式。

基本上都是同步的

## IO 模型-01

阻塞式 IO、BIO

一般通过在 while(true) 循环中服务 端会调用 accept() 方法等待接收客户 端的连接的方式监听请求，请求一旦 接收到一个连接请求，就可以建立通 信套接字在这个通信套接字上进行读 写操作，此时不能再接收其他客户端 连接请求，只能等待同当前连接的客 户端的操作执行完成， 不过可以通过 多线程来支持多个客户端的连接

## IO 模型-02

非阻塞式 IO

和阻塞 IO 类比，内核会立即返回，返 回后获得足够的 CPU 时间继续做其它 的事情。
用户进程第一个阶段不是阻塞的,需要 不断的主动询问 kernel 数据好了没有; 第二个阶段依然总是阻塞的。

## IO 模型-03

IO 多路复用(IO multiplexing)，也称事 件驱动 IO(event-driven IO)，就是在单 个线程里同时监控多个套接字，通过 select 或 poll 轮询所负责的所有 socket，当某个 socket 有数据到达了， 就通知用户进程。

IO 复用同非阻塞 IO 本质一样，不过利用 了新的 select 系统调用，由内核来负责 本来是请求进程该做的轮询操作。看似比 非阻塞 IO 还多了一个系统调用开销，不过因为可以支持多路 IO，才算提高了效率。

进程先是阻塞在 select/poll 上，再是阻 塞在读操作的第二个阶段上。

---

select/poll 的几大缺点:
(1)每次调用 select，都需要把 fd 集合从用户态拷贝到
内核态，这个开销在 fd 很多时会很大
(2)同时每次调用 select 都需要在内核遍历传递进来的
所有 fd，这个开销在 fd 很多时也很大
(3)select 支持的文件描述符数量太小了，默认是 1024

epoll(Linux 2.5.44 内核中引入,2.6 内核正式引入,可被用 于代替 POSIX select 和 poll 系统调用):
(1)内核与用户空间共享一块内存
(2)通过回调解决遍历问题
(3)fd 没有限制，可以支撑 10 万连接

## IO 模型-04

信号驱动 I/O

信号驱动 IO 与 BIO 和 NIO 最大的区 别就在于，在 IO 执行的数据准备阶段 ，不会阻塞用户进程。
如图所示:当用户进程需要等待数据 的时候，会向内核发送一个信号，告 诉内核我要什么数据，然后用户进程 就继续做别的事情去了，而当内核中 的数据准备好之后，内核立马发给用 户进程一个信号，说”数据准备好了， 快来查收“，用户进程收到信号之后， 立马调用 recvfrom，去查收数据。

## IO 模型-05

异步式 IO

异步 IO 真正实现了 IO 全流程的非阻 塞。用户进程发出系统调用后立即返 回，内核等待数据准备完成，然后将 数据拷贝到用户进程缓冲区，然后发 送信号告诉用户进程 IO 操作执行完毕 (与 SIGIO 相比，一个是发送信号告 诉用户进程数据准备完毕，一个是 IO 执行完毕)。
windows 的 IOCP 模型

---

一个场景，去打印店打印文件。

同步阻塞
直接排队，别的啥也干不成，直到轮
到你使用打印机了，自己打印文件

Reactor
拿个号码，回去该干嘛干嘛，等轮到
你使用打印机了，店主通知你来用打
印机，打印文件

Proactor
拿个号码，回去该干嘛干嘛，等轮到
你使用打印机了，店主直接给你打印
好文件，通知你来拿。

## 4. Netty 框架简介

## Netty 概览

网络应用开发框架

1. 异步
2. 事件驱动
3. 基于 NIO

适用于:

- 服务端
- 客户端
- TCP/UDP

## Netty 特性

- 高吞吐
- 低延迟
- 低开销
- 零拷贝
- 可扩容

- 松耦合: 网络和业务逻辑分离
- 使用方便、可维护性好

## 兼容性

JDK 兼容性:

- Netty 3.x: JDK5
- Netty 4.x: JDK6
- Netty 5.x: 已废弃

协议兼容性:

- 兼容大部分通用协议
- 支持自定义协议

嵌入式:

- HTTP Server
- HTTPS Server
- WebSocket Server
- TCP Server
- UDP Server
- In VM Pipe

Netty vs. Java EE?

## 基本概念

- Channel 通道，Java NIO 中的基础概念,代表一个打开的连接,可执行读取/写入 IO 操作。 Netty 对 Channel 的所有 IO 操作都是非阻塞的。
- ChannelFuture Java 的 Future 接口，只能查询操作的完成情况, 或者阻塞当前线程等待操作完成。 Netty 封装一个 ChannelFuture 接口。 我们可以将回调方法传给 ChannelFuture，在操作完成时自动执行。
- Event & Handler Netty 基于事件驱动，事件和处理器可以关联到入站和出站数据流。
- Encoder & Decoder 处理网络 IO 时，需要进行序列化和反序列化, 转换 Java 对象与字节流。 对入站数据进行解码, 基类是 ByteToMessageDecoder。 对出站数据进行编码, 基类是 MessageToByteEncoder。
- ChannelPipeline 数据处理管道就是事件处理器链。有顺序、同一 Channel 的出站处理器和入站处理器在同一个列表中。

## Event & Handler

入站事件:

- 通道激活和停用
- 读操作事件
- 异常事件
- 用户事件

出站事件:

- 打开连接
- 关闭连接
- 写入数据
- 刷新数据

事件处理程序接口:

- ChannelHandler
- ChannelOutboundHandler
- ChannelInboundHandler

适配器(空实现，需要继承使用):

- ChannelInboundHandlerAdapter
- ChannelOutboundHandlerAdapter

Netty 应用组成:

- 网络事件
- 应用程序逻辑事件
- 事件处理程序

# 5. Netty 使用示例

## Netty 简单例子

使用 Netty 改写
最开始的例子

然后，压测一下效果如何。

# 6. 总结回顾与作业实践

## 第四节课作业实践

1、(可选)运行课上的例子，以及 Netty 的例子，分析相关现象。
2、写一段代码，使用 HttpClient 或 OkHttp 访问 http://localhost:8801，代码提交到 Github。
