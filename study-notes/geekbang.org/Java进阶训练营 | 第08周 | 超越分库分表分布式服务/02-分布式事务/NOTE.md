# 1. 分布式事务

## 为什么需要分布式事务

    业务系统的复杂度提升，数据量的增加，比如导致出现分布式事务。

## 什么叫分布式事务

    分布式条件下，多个节点操作的整体事务一致性。
    特别是在微服务场景下，业务 A 和业务 B 关联，事务 A 成功，事务 B 失败，由于跨系统， 就会导致不被感知。此时从整体来看，数据是不一致的。

    此时，业务系统只能拿到不完全的 A 服务数据，缺失 B 服务的数据。

## 如何实现分布式下的一致性

    典型情况下是两个思路:
    1、理想状态:直接想单机数据库事务一样，多个数据库自动通过某种协调机制，实现了 跨数据库节点的一致性。
    使用场景:要求严格的一致性，比如金融交易类业务。

    2、一般情况:可以容忍一段时间的数据不一致，最终通过超时终止，调度补偿，等等方 式，实现数据的最终状态一致性。
    使用场景:准实时或非实时的处理，比如 T+1 的各类操作，或者电商类操作。

## 如何实现分布式下的一致性

    1、强一致 : XA

    2、弱一致 :
    1. 不用事务，业务侧补偿冲正
    2. 所谓的柔性事务，使用一套事务框架保证最终一致的事务

# 2. XA 分布式事务

## XA 分布式事务协议

    基于第一个强一致的思路，就有了基于数据库本身支持的协议，XA 分布式事务。
    XA 整体设计思路可以概括为，如何在现有事务模型上微调扩展，实现分布式事务。

    X/Open，即现在的 open group，是一个独立的组织，主要负责制定各种行 业技术标准。X/Open 组织主要由各大知名公司或者厂商进行支持，这些组 织不光遵循 X/Open 组织定义的行业技术标准，也参与到标准的

---

    应用程序(Application Program ，简称 AP):用于定义事务边界(即定义事务的开始和 结束)，并且在事务边界内对资源进行操作。
    资源管理器(Resource Manager，简称 RM):如数据库、文件系统等，并提供访问资源的方式
    事务管理器(Transaction Manager ，简称 TM):负责分配事务唯一标识，监控事务的执行 进度，并负责事务的提交、回滚等。

---

    XA 接口

    xa_start :负责开启或者恢复一个事务分支
    xa_end: 负责取消当前线程与事务分支的关联
    xa_prepare:询问 RM 是否准备好提交事务分支
    xa_commit:通知 RM 提交事务分支
    xa_rollback: 通知 RM 回滚事务分支
    xa_recover : 需要恢复的 XA 事务

    思考:为什么 XA 事务又叫两阶段事务?

---

    MySQL 从 5.0.3 开始支持 InnoDB 引擎的 XA 分布式事务，MySQL Connector/J 从 5.0.0 版本开始支持 XA。

    在 DTP 模型中，MySQL 属于资源管理器(RM)。分布式事务中存在多个 RM，由事务管理器 TM 来统一进行协调。

---

    - 思考一个问题:XA 过程中，事务失败怎么办?

    1、业务 SQL 执行过程，某个 RM 崩溃怎么处理?
    2、全部 prepare 后，某个 RM 崩溃怎么处理?
    3、commit 时，某个 RM 崩溃怎么办?

# 3. BASE 柔性事务

## BASE 柔性事务

    本地事务 -> XA(2PC) -> BASE

    如果将实现了 ACID 的事务要素的事务称为刚性事务的话，那么基于 BASE 事务要素的事务则称 为柔性事务。 BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写。
    • 基本可用(Basically Available)保证分布式事务参与方不一定同时在线。
    • 柔性状态(Soft state)则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够
    察觉。
    • 而最终一致性(Eventually consistent)通常是通过消息传递的方式保证系统的最终一致性。
    在 ACID 事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。 柔性事务的 理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求， 来换取系统吞吐量的提升。

---

    BASE 柔性事务常见模式
    1、TCC
    通过手动补偿处理

    2、AT
    通过自动补偿处理

# 4. TCC/AT 以及相关框架

## 什么是 TCC

    BASE 柔性事务 TCC
    TCC 模式即将每个服务业务操作分为两个阶段，第一个阶段检查并预留相关资源，第二阶段根据所有 服务业务的 Try 状态来操作，如果都成功，则进行 Confirm 操作，如果任意一个 Try 发生错误，则 全部 Cancel。

    TCC 使用要求就是业务接口都必须实现三段逻辑:

    1.准备操作 Try:完成所有业务检查，预留必须的业务资源。
    2.确认操作 Confirm:真正执行的业务逻辑，不做任何业务检查，只使用 Try 阶段预留的业务资源 。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一 笔分布式事务能且只能成功一次。
    3.取消操作 Cancel:释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。

---

    TCC 不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务， 不同于AT的是就是需要自行定义各个阶段的逻辑，对业务有侵入。

---

    TCC 需要注意的几个问题:
    1、允许空回滚
    2、防悬挂控制
    3、幂等设计
