# 1. Java Socket 编程

## 服务器通信原理

## Java 实现一个最简的 HTTP 服务器-01

      1. 创建一个 ServerSocket
      2. 绑定 8801 端口
      3. 当有客户端请求时通过 accept 方法拿 到 Socket，进而可以进行处理
      4. sleep 20ms，模拟业务操作(IO)
      5. 模拟输出 HTTP 报文头和 hello
      6. 关闭 socket
         可以浏览器访问 http://localhost:8801 思考一下有什么问题?

      设置-Xmx512 然后启动
      压测:
      sb -u http://localhost:8801 -c 40 -N 30
      wrk -c 40 -d30s http://localhost:8801

## Java 实现一个最简的 HTTP 服务器-02

      改进一下，绑定 8802 端口
      每个客户端请求进来时创建一个线程
      有什么问题?

      设置-Xmx512 然后启动
      压测:
      sb -u http://localhost:8802 -c 40 -N 30
      wrk -c 40 -d30s http://localhost:8802

## Java 实现一个最简的 HTTP 服务器-03

      再改进一下，绑定 8802 端口
      创建一个固定大小的线程池来处理
      why?
      有什么问题?

      设置-Xmx512 然后启动
      压测:
      sb -u http://localhost:8803 -c 40 -N 30
      wrk -c 40 -d30s http://localhost:8803

## 总结一下，到目前为止，我们做了什么

      单线程处理 socket
      每个请求一个线程
      固定大小线程池处理

# 2. 深入讨论 IO 通信

## 服务器通信过程分析

      仔细分析一下，
      这个过程中，存在两种类型操作:

      - CPU 计算/业务处理
      - IO 操作与等待/网络、磁盘、数据库

      想想我们前面的例子为什么创建大量线程?

      对于一个 IO 相关应用来说， 例如通过网络访问，服务器端读取本
      地文件，再返回给客户端(如左图)。

      这种情况下，
      大部分 CPU 等资源，可能就被浪费了。

## 再深入一层的看问题

      不仅面临线程 /CPU 的问题，

      还要面对数据来回复制的问题。

      这个一来，对每个业务处理过程，使
      用一个线程以一竿子通到底的方式，
      性能不是最优的，还有提升空间。

      考虑一下，理想状态，是什么样的?
      流水线

# 3. NIO 模型与相关概念

## 通信模型

      考虑一下:

      阻塞、非阻塞，
      同步、异步，

      有什么关系和区别?

      - 同步异步 是通信模式。
      - 阻塞、非阻塞 是 线程处理模式。

      基本上都是同步的

## IO 模型-01

      阻塞式 IO、BIO

      一般通过在 while(true) 循环中服务 端会调用 accept() 方法等待接收客户 端的连接的方式监听请求，请求一旦 接收到一个连接请求，就可以建立通 信套接字在这个通信套接字上进行读 写操作，此时不能再接收其他客户端 连接请求，只能等待同当前连接的客 户端的操作执行完成， 不过可以通过 多线程来支持多个客户端的连接

## IO 模型-02

      非阻塞式 IO

      和阻塞 IO 类比，内核会立即返回，返 回后获得足够的 CPU 时间继续做其它 的事情。
      用户进程第一个阶段不是阻塞的,需要 不断的主动询问 kernel 数据好了没有; 第二个阶段依然总是阻塞的。

## IO 模型-03

      IO 多路复用(IO multiplexing)，也称事 件驱动 IO(event-driven IO)，就是在单 个线程里同时监控多个套接字，通过 select 或 poll 轮询所负责的所有 socket，当某个 socket 有数据到达了， 就通知用户进程。

      IO 复用同非阻塞 IO 本质一样，不过利用 了新的 select 系统调用，由内核来负责 本来是请求进程该做的轮询操作。看似比 非阻塞 IO 还多了一个系统调用开销，不过因为可以支持多路 IO，才算提高了效率。

      进程先是阻塞在 select/poll 上，再是阻 塞在读操作的第二个阶段上。

---

      select/poll 的几大缺点:
      (1)每次调用 select，都需要把 fd 集合从用户态拷贝到
      内核态，这个开销在 fd 很多时会很大
      (2)同时每次调用 select 都需要在内核遍历传递进来的
      所有 fd，这个开销在 fd 很多时也很大
      (3)select 支持的文件描述符数量太小了，默认是 1024

      epoll(Linux 2.5.44 内核中引入,2.6 内核正式引入,可被用 于代替 POSIX select 和 poll 系统调用):
      (1)内核与用户空间共享一块内存
      (2)通过回调解决遍历问题
      (3)fd 没有限制，可以支撑 10 万连接

## IO 模型-04

      信号驱动 I/O

      信号驱动 IO 与 BIO 和 NIO 最大的区 别就在于，在 IO 执行的数据准备阶段 ，不会阻塞用户进程。
      如图所示:当用户进程需要等待数据 的时候，会向内核发送一个信号，告 诉内核我要什么数据，然后用户进程 就继续做别的事情去了，而当内核中 的数据准备好之后，内核立马发给用 户进程一个信号，说”数据准备好了， 快来查收“，用户进程收到信号之后， 立马调用 recvfrom，去查收数据。

## IO 模型-05

      异步式 IO

      异步 IO 真正实现了 IO 全流程的非阻 塞。用户进程发出系统调用后立即返 回，内核等待数据准备完成，然后将 数据拷贝到用户进程缓冲区，然后发 送信号告诉用户进程 IO 操作执行完毕 (与 SIGIO 相比，一个是发送信号告 诉用户进程数据准备完毕，一个是 IO 执行完毕)。
      windows 的 IOCP 模型

---

      一个场景，去打印店打印文件。

      同步阻塞
      直接排队，别的啥也干不成，直到轮
      到你使用打印机了，自己打印文件

      Reactor
      拿个号码，回去该干嘛干嘛，等轮到
      你使用打印机了，店主通知你来用打
      印机，打印文件

      Proactor
      拿个号码，回去该干嘛干嘛，等轮到
      你使用打印机了，店主直接给你打印
      好文件，通知你来拿。

## 4. Netty 框架简介

## Netty 概览

      网络应用开发框架

      1. 异步
      2. 事件驱动
      3. 基于 NIO

      适用于:

      - 服务端
      - 客户端
      - TCP/UDP

## Netty 特性

      - 高吞吐
      - 低延迟
      - 低开销
      - 零拷贝
      - 可扩容

      - 松耦合: 网络和业务逻辑分离
      - 使用方便、可维护性好

## 兼容性

      JDK 兼容性:

      - Netty 3.x: JDK5
      - Netty 4.x: JDK6
      - Netty 5.x: 已废弃

      协议兼容性:

      - 兼容大部分通用协议
      - 支持自定义协议

      嵌入式:

      - HTTP Server
      - HTTPS Server
      - WebSocket Server
      - TCP Server
      - UDP Server
      - In VM Pipe

      Netty vs. Java EE?

## 基本概念

      - Channel 通道，Java NIO 中的基础概念,代表一个打开的连接,可执行读取/写入 IO 操作。 Netty 对 Channel 的所有 IO 操作都是非阻塞的。
      - ChannelFuture Java 的 Future 接口，只能查询操作的完成情况, 或者阻塞当前线程等待操作完成。 Netty 封装一个 ChannelFuture 接口。 我们可以将回调方法传给 ChannelFuture，在操作完成时自动执行。
      - Event & Handler Netty 基于事件驱动，事件和处理器可以关联到入站和出站数据流。
      - Encoder & Decoder 处理网络 IO 时，需要进行序列化和反序列化, 转换 Java 对象与字节流。 对入站数据进行解码, 基类是 ByteToMessageDecoder。 对出站数据进行编码, 基类是 MessageToByteEncoder。
      - ChannelPipeline 数据处理管道就是事件处理器链。有顺序、同一 Channel 的出站处理器和入站处理器在同一个列表中。

## Event & Handler

      入站事件:

      - 通道激活和停用
      - 读操作事件
      - 异常事件
      - 用户事件

      出站事件:

      - 打开连接
      - 关闭连接
      - 写入数据
      - 刷新数据

      事件处理程序接口:

      - ChannelHandler
      - ChannelOutboundHandler
      - ChannelInboundHandler

      适配器(空实现，需要继承使用):

      - ChannelInboundHandlerAdapter
      - ChannelOutboundHandlerAdapter

      Netty 应用组成:

      - 网络事件
      - 应用程序逻辑事件
      - 事件处理程序

# 5. Netty 使用示例

## Netty 简单例子

      使用 Netty 改写
      最开始的例子

      然后，压测一下效果如何。

# 6. 总结回顾与作业实践

## 第四节课作业实践

      1、(可选)运行课上的例子，以及 Netty 的例子，分析相关现象。
      2、写一段代码，使用 HttpClient 或 OkHttp 访问 http://localhost:8801，代码提交到 Github。
